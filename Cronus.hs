{-# LANGUAGE NoImplicitPrelude #-}
module Cronus
( Bool(True, False)
, (&&), (||), not, otherwise
, Maybe(Just, Nothing)
, maybe
, Either(Left, Right)
, either
, Ordering(LT, EQ, GT)
, Char
, isControl
, isSpace
, isLower
, isUpper
, isAlpha
, isAlphaNum
, isPrint
, isDigit
, isOctDigit
, isHexDigit
, isLetter
, isMark
, isNumber
, isPunctuation
, isSymbol
, isSeparator
, isAscii
, isLatin1
, isAsciiUpper
, isAsciiLower
, ord
, chr
, fst, snd
, curry
, uncurry
, Eq(..)
, Ord(..)
, Enum(..)
, Bounded(..)
, Int
, Int8, Int16, Int32, Int64
, Integer
, Natural
, Float
, Double
, Word
, Word8, Word16, Word32, Word64
, Rational
, Num(..), subtract
, Real(toRational)
, Integral(..)
, Fractional(..)
, Floating(..)
, RealFrac(..)
, RealFloat(..)
, even
, odd
, gcd
, lcm
, (^)
, (^^)
, fromIntegral
, realToFrac
, Show(..)
, Read(..)
, readMaybe
, Semigroup(..)
, Monoid(..)
, Functor(..)
, Monad(..)
, mfilter
, mapAndUnzipM
, zipWithM
, zipWithM_
, foldM
, foldM_
, replicateM
, replicateM_
, guard
, when
, unless
, liftM
, liftM2
, liftM3
, liftM4
, liftM5
, ap 
, (<$!>)
, Applicative(..)
, ZipList(..)
, (<**>)
, liftA
, liftA3
, optional
, Alternative(..)
, MonadPlus(..)
, MonadFail(..)
, mapM_
, sequence_
, (=<<)
, Foldable(..)
, Traversable(..)
, (<$>)
, Category(..)
, (&)
, ($)
, on
, flip
, const
, until
, error
, undefined
, seq
, ($!)
, (++)
, reverse
, and
, or
, any
, all
, concat
, concatMap
, scanl
, scanr
, iterate
, repeat
, replicate
, cycle
, take
, drop
, takeWhile
, dropWhile
, span
, break
, splitAt
, notElem
, lookup
, zip
, zip3
, zipWith
, zipWith3
, unzip
, unzip3
, IO
, ST
, runST
, throwIO
, SomeException
, Typeable(..)
, typeOf
, typeRep
, TypeRep
, Proxy(Proxy)
, (:~:)(Refl)
, (:~~:)(HRefl)
, cast
, eqT
, gcast
, gcast1
, gcast2
, typeRepFingerprint
, Exception(..)
, catch
, ArithException(..)
, ArrayException(..)
, AssertionFailed(..)
, SomeAsyncException(..)
, AsyncException(..)
, asyncExceptionToException
, asyncExceptionFromException
, NonTermination(..)
, NestedAtomically(..)
, BlockedIndefinitelyOnMVar(..)
, BlockedIndefinitelyOnSTM(..)
, AllocationLimitExceeded(..)
, CompactionFailed(..)
, Deadlock(..)
, NoMethodError(..)
, PatternMatchFail(..)
, RecConError(..)
, RecSelError(..)
, RecUpdError(..)
, ErrorCall(..)
, TypeError(..)
, throw
, ioError
, IOError
, catches
, Handler(..)
, catchJust
, handle
, handleJust
, try
, tryJust
, evaluate
, mapException
, mask
, mask_
, uninterruptibleMask
, uninterruptibleMask_
, MaskingState(..)
, getMaskingState
, interruptible
, allowInterrupt
, assert
, bracket
, bracket_
, bracketOnError
, finally
, onException
, forkIO
, ThreadId
, myThreadId
, forkFinally
, forkIOWithUnmask
, killThread
, throwTo
, forkOn
, forkOnWithUnmask
, getNumCapabilities
, setNumCapabilities
, threadCapability
, yield
, threadDelay
, threadWaitRead
, threadWaitWrite
, threadWaitReadSTM
, MVar
, newMVar
, takeMVar
, readMVar
, swapMVar
, tryTakeMVar
, putMVar
, tryPutMVar
, withMVar
, isEmptyMVar
, modifyMVar_
, modifyMVar
, modifyMVarMasked
, tryReadMVar
, mkWeakMVar
, Chan
, newChan
, writeChan
, readChan
, dupChan
, getChanContents
, writeList2Chan
, QSem
, newQSem
, waitQSem
, signalQSem
, QSemN
, newQSemN
, waitQSemN
, signalQSemN
, rtsSupportsBoundThreads
, forkOSWithUnmask
, isCurrentThreadBound
, runInBoundThread
, runInUnboundThread
, mkWeakThreadId
, deepseq
, ($!!)
, force
, NFData(..)
, ByteString
, Text
, Graph
, IntMap
, Map
, Set
, Seq
, IntSet
, Tree
, Hashable(..)
, HashMap
, HashSet
, MonadTrans(lift)
, MonadIO(liftIO)
, ReaderT(..)
, MonadReader(..)
, asks
, Reader
, runReader
, mapReader
, withReader
, StateT(..)
, MonadState(..)
, State
, modify
, modify'
, gets
, WriterT(..)
, MonadWriter(..)
, listens
, censor
, Writer
, runWriter
, execWriter
, mapWriter
, execWriterT
, mapWriterT
, MaybeT(..)
, mapMaybeT
, maybeToExceptT
, exceptToMaybeT
, ExceptT(..)
, Except
, except
, runExcept
, mapExcept
, withExcept
, mapExceptT
, withExceptT
, throwE
, catchE
, RWST(..)
, RWS
, rws
, runRWS
, evalRWS
, execRWS
, mapRWS
, withRWS
, evalRWST
, execRWST
, mapRWST
, withRWST
, Identity(..)
, Const(..)
, Sum(..)
, Product(..)
, Compose(..)
, Contravariant(..)
, Unique(..)
, newUnique
, hashUnique
, Version(..)
, Void(..)
, Bitraversable(..)
, bisequenceA
, bisequence
, bimapM
, bifor
, biforM
, bimapAccumL
, bimapAccumR
, bimapDefault
, bifoldMapDefault
, Coercible
, coerce
, Dynamic
, toDyn
, fromDyn
, fromDynamic
, dynApply
, dynApp
, dynTypeRep
, catMaybes
, mapMaybe
, listToMaybe
, maybeToList
, fromMaybe
, isNothing
, isJust
, lefts
, rights
, isLeft
, isRight
, fromLeft
, fromRight
, partitionEithers
, foldrM
, foldlM
, traverse_
, for_
, sequenceA_
, asum
, forM_
, forM
, msum
, maximumBy
, minimumBy
, find
, for
, mapAccumL
, mapAccumR
, Ix(..)
, IORef
, newIORef
, readIORef
, writeIORef
, modifyIORef
, modifyIORef'
, atomicModifyIORef
, atomicModifyIORef'
, atomicWriteIORef
, mkWeakIORef
, STRef
, newSTRef
, writeSTRef
, modifySTRef
, modifySTRef'
, MonadFix(..)
, fix
, (&&&)
, (***)
, Kleisli(..)
, (>>>)
, (<<<)
, Bifunctor(..)
, Profunctor(..)
, Strong(..)
, Choice(..)
, Closed(..)
, curry'
, Mapping(..)
, Costrong(..)
, Cochoice(..)
, Star(..)
, Costar(..)
, Forget(..)
, Vector
, MVector
, Unbox(..)
, Comonad(..)
, liftW
, wfix
, cfix
, kfix
, (=>=)
, (=<=)
, (<<=)
, (=>>)
, ComonadApply(..)
, (<@@>)
, liftW2
, liftW3
, Cokleisli(..)
) where

import Data.Profunctor
import Data.Bifunctor (Bifunctor(..))
import Control.Arrow ((&&&), (***), Kleisli(..))
import Data.Function ((&), ($), on, flip, const)
import Control.Category
import GHC.Num
import Prelude hiding ((.), id)
import Data.Int
import Control.Monad
import Control.Applicative
import Data.Word
import Data.Foldable
import Data.Traversable
import Text.Read
import Control.Monad.ST
import Control.Concurrent
import Control.Exception
import Data.Typeable
import Control.DeepSeq
import Text.Read (readMaybe)
import Data.ByteString (ByteString)
import Data.Text (Text)
import Data.IntMap (IntMap)
import Data.IntMap.Lazy (IntMap)
import Data.Graph (Graph)
import Data.Map (Map)
import Data.Sequence (Seq)
import Data.Set (Set)
import Data.IntSet (IntSet)
import Data.Tree (Tree)
import Data.HashMap.Lazy (HashMap)
import Data.HashMap.Strict (HashMap)
import Data.HashSet (HashSet)
import Data.Hashable
import Control.Monad.Trans
import Control.Monad.Reader
import Control.Monad.State
import Control.Monad.Writer (MonadWriter(..))
import Control.Monad.Trans.Writer.CPS
import Control.Monad.Trans.Maybe
import Control.Monad.Trans.RWS.CPS hiding (reader, ask, local, asks, writer, tell, listen, listens, pass, censor, state, get, put, modify, gets)
import Control.Monad.Trans.Except
import Data.Functor.Identity
import Data.Functor.Const
import Data.Functor.Sum
import Data.Functor.Product
import Data.Functor.Compose
import Data.Functor.Contravariant
import Data.Unique
import Data.Version
import Data.Bitraversable
import Data.Void
import Data.Coerce (Coercible, coerce)
import Data.Dynamic
import Data.Maybe
import Data.Either
import Data.Ix
import Data.IORef
import Data.STRef
import Data.Char
import Data.Vector.Unboxed (Vector, MVector, Unbox(..))
import Control.Comonad
